## How to read this Book

All my books are **not meant** to be comprehensive reference guides or in-depth reads about the technology itself. Instead, they are written as tutorials as you will find them online nowadays. However, most online tutorials are not consistent, often out-of-date, teach too many things at once, and never answer the *why* but only show off the *how*. I do my best to avoid these pitfalls in my books with the experience I gathered over the last years of writing technical content. You will be guided through building applications by typing out the code yourself, running into issues, and fixing them. You will learn about the *why* and not only the *how*. After you have finished this book and the application(s), you should feel comfortable in any source code related to the technology. This book is not only about reading it, but about getting your hands dirty. After all, I hope my books offer you the best practical introduction to a topic that is available as written content.

### State of Flow

I reason that few people have learned to create source code from reading a book, and that programming is about the practical experience of conquering challenges and strengthening your development skills. Paradigms like functional programming and object-oriented programming require more extensive trial and error to use practically. Complex concepts like state management or control flow management used in modern web applications, libraries, and frameworks will take more than a weekend to master. These concepts can only be learned through consistent practice.

This book provides a more hands-on experience and challenges to help you grow as a software engineer. The challenges are meant to create a flow experience, a scenario where obstacles are met by your skills and tools. The idea is to keep the balance of challenging you and respecting your skill level so you can experience a [state of flow](https://www.robinwieruch.de/lessons-learned-deep-work-flow/).

### Exercises

As mentioned, there are practical tasks in this book presented as exercises to fortify what you learned in previous sections. The tasks will include practical uses for the lessons, and deeper understanding of abstract content for your own projects. Most of the exercises come with the entire source code you have coded until then as well. Use this source code to track down bugs in case you ran into an issue in one of the sections.

### Stepping Stones

Remember to internalize each lesson before you continue with the next section. The lessons build on the one before, and the difficulty of each topic scales horizontally using techniques side-by-side, and vertically using technique-on-technique. Its much easier to retain information if you take notes, so consider writing down questions that aren't covered in the text so you can look them up afterward. These notes can also become feedback, which I use to improve future versions.

### DIY

I encourage you to write out code examples instead of copying and pasting them. Typing out code teaches how to find syntax errors and bugs, and you'll be better equipped fix errors once you've started trying the examples on your own. Don't get discouraged if you encounter bugs, as they usually appear in any application that is complex enough. It is acceptable to find them in learning scenarios because you'll have a chance to learn how to fix them.

### Learn your Tools

These materials should be absorbed with an IDE or editor/terminal combination to type out the examples and observe the output. I provide additional tools that will support you with the implementation. Between the lessons, experiment with your applications and apply the tools you've acquired. After all, application is the only way to mastery.